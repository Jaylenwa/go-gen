package gen

import (
	"github.com/gogf/gf-cli/v2/library/mlog"
	"github.com/gogf/gf-cli/v2/library/utils"
	"github.com/gogf/gf/v2/os/gfile"
	"strings"
)

func GenPkg(req GenReq) {
	genInitConfig(req)
	genErrorHandler(req)
	genRouter(req)
	genConcurrentMap(req)
}

func genInitConfig(req GenReq) {
	str := "package config\n\nimport (\n\t\"gopkg.in/yaml.v3\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"sync\"\n)\n\ntype Project struct {\n\tHost    string `yaml:\"host\"`\n\tPort    int    `yaml:\"port\"`\n\tPortPub int    `yaml:\"port_pub\"`\n\tPortPri int    `yaml:\"port_pri\"`\n}\n\ntype MySQL struct {\n\tUsername        string `yaml:\"username\"`\n\tPassword        string `yaml:\"password\"`\n\tDbHost          string `yaml:\"db_host\"`\n\tDbPort          int    `yaml:\"db_port\"`\n\tDbName          string `yaml:\"db_name\"`\n\tCharset         string `yaml:\"charset\"`\n\tTimeout         string `yaml:\"timeout\"`\n\tTimeoutRead     string `yaml:\"timeout_read\"`\n\tTimeoutWrite    string `yaml:\"timeout_write\"`\n\tMaxOpenConns    int    `yaml:\"max_open_conns\"`\n\tMaxIdleConns    int    `yaml:\"max_idle_conns\"`\n\tConnMaxLifetime int    `yaml:\"conn_max_lifetime\"`\n}\n\ntype Redis struct {\n\tHost       string `yaml:\"host\"`\n\tPort       string `yaml:\"port\"`\n\tPassword   string `yaml:\"password\"`\n\tDB         int    `yaml:\"db\"`\n\tMaxRetries int    `yaml:\"max_retries\"`\n\tPoolSize   int    `yaml:\"pool_size\"`\n}\n\ntype Config struct {\n\tProject Project `yaml:\"project\"`\n\tMySQL   MySQL   `yaml:\"mysql\"`\n\tRedis   Redis   `yaml:\"redis\"`\n}\n\nvar (\n\tconfigOnce sync.Once\n\tconfigImpl *Config\n)\n\nfunc NewConfig() *Config {\n\tconfigOnce.Do(func() {\n\n\t\t// 生产环境\n\t\tconfigFilePath := \"config.yaml\"\n\n\t\tconf := &Config{}\n\t\terr := conf.loadConfig(configFilePath)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"load %v failed: %v\", configFilePath, err)\n\t\t\treturn\n\t\t}\n\t})\n\n\treturn configImpl\n}\n\n// loadConfig 加载配置\nfunc (conf *Config) loadConfig(path string) (err error) {\n\n\tfile, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tlog.Fatalf(\"load %v failed: %v\", path, err)\n\t}\n\n\terr = yaml.Unmarshal(file, &configImpl)\n\tif err != nil {\n\t\tlog.Fatalf(\"unmarshal yaml file failed: %v\", err)\n\t}\n\n\treturn\n}\n"
	path := req.ConfigDir + "/config.go"
	if err := gfile.PutContents(path, strings.TrimSpace(str)); err != nil {
		mlog.Fatalf("writing content to '%s' failed: %v", path, err)
	} else {
		utils.GoFmt(path)
		mlog.Print("generated:", path)
	}
}

func genErrorHandler(req GenReq) {
	str := "package middleware\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc ErrorHandlerMiddleware() gin.HandlerFunc {\n\treturn func(c *gin.Context) {\n\t\t// 错误处理\n\t\tdefer func() {\n\t\t\tfor _, err := range c.Errors {\n\t\t\t\tc.AbortWithStatusJSON(c.Writer.Status(), gin.H{\n\t\t\t\t\t\"code\":    c.Writer.Status(),\n\t\t\t\t\t\"message\": http.StatusText(c.Writer.Status()),\n\t\t\t\t\t\"cause\":   err.Error(),\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t}\n\t\t}()\n\t\tc.Writer.Header().Set(\"Content-Type\", \"application/json; charset=utf-8\")\n\t\tc.Next()\n\t}\n}"
	path := req.middlewareDir + "/error_handler.go"
	if err := gfile.PutContents(path, strings.TrimSpace(str)); err != nil {
		mlog.Fatalf("writing content to '%s' failed: %v", path, err)
	} else {
		utils.GoFmt(path)
		mlog.Print("generated:", path)
	}
}

func genRouter(req GenReq) {
	str := "package driver\n\nimport \"github.com/gin-gonic/gin\"\n\n// HttpRouterInterface 路由公共接口\ntype HttpRouterInterface interface {\n\t// RegisterRouterPublic 注册外部API\n\tRegisterRouterPublic(engine *gin.RouterGroup)\n\n\t// RegisterRouterPrivate 注册内部API\n\tRegisterRouterPrivate(engine *gin.RouterGroup)\n}\n"
	path := req.RouterDir + "/router.go"
	if err := gfile.PutContents(path, strings.TrimSpace(str)); err != nil {
		mlog.Fatalf("writing content to '%s' failed: %v", path, err)
	} else {
		utils.GoFmt(path)
		mlog.Print("generated:", path)
	}
}

func genConcurrentMap(req GenReq) {
	str := "package cmap\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"sync\"\n)\n\nvar SHARD_COUNT = 32\n\ntype Stringer interface {\n\tfmt.Stringer\n\tcomparable\n}\n\n// A \"thread\" safe map of type string:Anything.\n// To avoid lock bottlenecks this map is dived to several (SHARD_COUNT) map shards.\ntype ConcurrentMap[K comparable, V any] struct {\n\tshards   []*ConcurrentMapShared[K, V]\n\tsharding func(key K) uint32\n}\n\n// A \"thread\" safe string to anything map.\ntype ConcurrentMapShared[K comparable, V any] struct {\n\titems        map[K]V\n\tsync.RWMutex // Read Write mutex, guards access to internal map.\n}\n\nfunc create[K comparable, V any](sharding func(key K) uint32) ConcurrentMap[K, V] {\n\tm := ConcurrentMap[K, V]{\n\t\tsharding: sharding,\n\t\tshards:   make([]*ConcurrentMapShared[K, V], SHARD_COUNT),\n\t}\n\tfor i := 0; i < SHARD_COUNT; i++ {\n\t\tm.shards[i] = &ConcurrentMapShared[K, V]{items: make(map[K]V)}\n\t}\n\treturn m\n}\n\n// Creates a new concurrent map.\nfunc New[V any]() ConcurrentMap[string, V] {\n\treturn create[string, V](fnv32)\n}\n\n// Creates a new concurrent map.\nfunc NewStringer[K Stringer, V any]() ConcurrentMap[K, V] {\n\treturn create[K, V](strfnv32[K])\n}\n\n// Creates a new concurrent map.\nfunc NewWithCustomShardingFunction[K comparable, V any](sharding func(key K) uint32) ConcurrentMap[K, V] {\n\treturn create[K, V](sharding)\n}\n\n// GetShard returns shard under given key\nfunc (m ConcurrentMap[K, V]) GetShard(key K) *ConcurrentMapShared[K, V] {\n\treturn m.shards[uint(m.sharding(key))%uint(SHARD_COUNT)]\n}\n\nfunc (m ConcurrentMap[K, V]) MSet(data map[K]V) {\n\tfor key, value := range data {\n\t\tshard := m.GetShard(key)\n\t\tshard.Lock()\n\t\tshard.items[key] = value\n\t\tshard.Unlock()\n\t}\n}\n\n// Sets the given value under the specified key.\nfunc (m ConcurrentMap[K, V]) Set(key K, value V) {\n\t// Get map shard.\n\tshard := m.GetShard(key)\n\tshard.Lock()\n\tshard.items[key] = value\n\tshard.Unlock()\n}\n\n// Callback to return new element to be inserted into the map\n// It is called while lock is held, therefore it MUST NOT\n// try to access other keys in same map, as it can lead to deadlock since\n// Go sync.RWLock is not reentrant\ntype UpsertCb[V any] func(exist bool, valueInMap V, newValue V) V\n\n// Insert or Update - updates existing element or inserts a new one using UpsertCb\nfunc (m ConcurrentMap[K, V]) Upsert(key K, value V, cb UpsertCb[V]) (res V) {\n\tshard := m.GetShard(key)\n\tshard.Lock()\n\tv, ok := shard.items[key]\n\tres = cb(ok, v, value)\n\tshard.items[key] = res\n\tshard.Unlock()\n\treturn res\n}\n\n// Sets the given value under the specified key if no value was associated with it.\nfunc (m ConcurrentMap[K, V]) SetIfAbsent(key K, value V) bool {\n\t// Get map shard.\n\tshard := m.GetShard(key)\n\tshard.Lock()\n\t_, ok := shard.items[key]\n\tif !ok {\n\t\tshard.items[key] = value\n\t}\n\tshard.Unlock()\n\treturn !ok\n}\n\n// Get retrieves an element from map under given key.\nfunc (m ConcurrentMap[K, V]) Get(key K) (V, bool) {\n\t// Get shard\n\tshard := m.GetShard(key)\n\tshard.RLock()\n\t// Get item from shard.\n\tval, ok := shard.items[key]\n\tshard.RUnlock()\n\treturn val, ok\n}\n\n// Count returns the number of elements within the map.\nfunc (m ConcurrentMap[K, V]) Count() int {\n\tcount := 0\n\tfor i := 0; i < SHARD_COUNT; i++ {\n\t\tshard := m.shards[i]\n\t\tshard.RLock()\n\t\tcount += len(shard.items)\n\t\tshard.RUnlock()\n\t}\n\treturn count\n}\n\n// Looks up an item under specified key\nfunc (m ConcurrentMap[K, V]) Has(key K) bool {\n\t// Get shard\n\tshard := m.GetShard(key)\n\tshard.RLock()\n\t// See if element is within shard.\n\t_, ok := shard.items[key]\n\tshard.RUnlock()\n\treturn ok\n}\n\n// Remove removes an element from the map.\nfunc (m ConcurrentMap[K, V]) Remove(keys ...K) {\n\t// Try to get shard.\n\tfor _, k := range keys {\n\t\tshard := m.GetShard(k)\n\t\tshard.Lock()\n\t\tdelete(shard.items, k)\n\t\tshard.Unlock()\n\t}\n}\n\n// RemoveCb is a callback executed in a map.RemoveCb() call, while Lock is held\n// If returns true, the element will be removed from the map\ntype RemoveCb[K any, V any] func(key K, v V, exists bool) bool\n\n// RemoveCb locks the shard containing the key, retrieves its current value and calls the callback with those params\n// If callback returns true and element exists, it will remove it from the map\n// Returns the value returned by the callback (even if element was not present in the map)\nfunc (m ConcurrentMap[K, V]) RemoveCb(key K, cb RemoveCb[K, V]) bool {\n\t// Try to get shard.\n\tshard := m.GetShard(key)\n\tshard.Lock()\n\tv, ok := shard.items[key]\n\tremove := cb(key, v, ok)\n\tif remove && ok {\n\t\tdelete(shard.items, key)\n\t}\n\tshard.Unlock()\n\treturn remove\n}\n\n// Pop removes an element from the map and returns it\nfunc (m ConcurrentMap[K, V]) Pop(key K) (v V, exists bool) {\n\t// Try to get shard.\n\tshard := m.GetShard(key)\n\tshard.Lock()\n\tv, exists = shard.items[key]\n\tdelete(shard.items, key)\n\tshard.Unlock()\n\treturn v, exists\n}\n\n// IsEmpty checks if map is empty.\nfunc (m ConcurrentMap[K, V]) IsEmpty() bool {\n\treturn m.Count() == 0\n}\n\n// Used by the Iter & IterBuffered functions to wrap two variables together over a channel,\ntype Tuple[K comparable, V any] struct {\n\tKey K\n\tVal V\n}\n\n// Iter returns an iterator which could be used in a for range loop.\n//\n// Deprecated: using IterBuffered() will get a better performence\nfunc (m ConcurrentMap[K, V]) Iter() <-chan Tuple[K, V] {\n\tchans := snapshot(m)\n\tch := make(chan Tuple[K, V])\n\tgo fanIn(chans, ch)\n\treturn ch\n}\n\n// IterBuffered returns a buffered iterator which could be used in a for range loop.\nfunc (m ConcurrentMap[K, V]) IterBuffered() <-chan Tuple[K, V] {\n\tchans := snapshot(m)\n\ttotal := 0\n\tfor _, c := range chans {\n\t\ttotal += cap(c)\n\t}\n\tch := make(chan Tuple[K, V], total)\n\tgo fanIn(chans, ch)\n\treturn ch\n}\n\n// Clear removes all items from map.\nfunc (m ConcurrentMap[K, V]) Clear() {\n\tfor item := range m.IterBuffered() {\n\t\tm.Remove(item.Key)\n\t}\n}\n\n// Returns a array of channels that contains elements in each shard,\n// which likely takes a snapshot of `m`.\n// It returns once the size of each buffered channel is determined,\n// before all the channels are populated using goroutines.\nfunc snapshot[K comparable, V any](m ConcurrentMap[K, V]) (chans []chan Tuple[K, V]) {\n\t//When you access map items before initializing.\n\tif len(m.shards) == 0 {\n\t\tpanic(`cmap.ConcurrentMap is not initialized. Should run New() before usage.`)\n\t}\n\tchans = make([]chan Tuple[K, V], SHARD_COUNT)\n\twg := sync.WaitGroup{}\n\twg.Add(SHARD_COUNT)\n\t// Foreach shard.\n\tfor index, shard := range m.shards {\n\t\tgo func(index int, shard *ConcurrentMapShared[K, V]) {\n\t\t\t// Foreach key, value pair.\n\t\t\tshard.RLock()\n\t\t\tchans[index] = make(chan Tuple[K, V], len(shard.items))\n\t\t\twg.Done()\n\t\t\tfor key, val := range shard.items {\n\t\t\t\tchans[index] <- Tuple[K, V]{key, val}\n\t\t\t}\n\t\t\tshard.RUnlock()\n\t\t\tclose(chans[index])\n\t\t}(index, shard)\n\t}\n\twg.Wait()\n\treturn chans\n}\n\n// fanIn reads elements from channels `chans` into channel `out`\nfunc fanIn[K comparable, V any](chans []chan Tuple[K, V], out chan Tuple[K, V]) {\n\twg := sync.WaitGroup{}\n\twg.Add(len(chans))\n\tfor _, ch := range chans {\n\t\tgo func(ch chan Tuple[K, V]) {\n\t\t\tfor t := range ch {\n\t\t\t\tout <- t\n\t\t\t}\n\t\t\twg.Done()\n\t\t}(ch)\n\t}\n\twg.Wait()\n\tclose(out)\n}\n\n// Items returns all items as map[string]V\nfunc (m ConcurrentMap[K, V]) Items() map[K]V {\n\ttmp := make(map[K]V)\n\n\t// Insert items to temporary map.\n\tfor item := range m.IterBuffered() {\n\t\ttmp[item.Key] = item.Val\n\t}\n\n\treturn tmp\n}\n\n// Iterator callbacalled for every key,value found in\n// maps. RLock is held for all calls for a given shard\n// therefore callback sess consistent view of a shard,\n// but not across the shards\ntype IterCb[K comparable, V any] func(key K, v V) bool\n\n// Callback based iterator, cheapest way to read\n// all elements in a map.\nfunc (m ConcurrentMap[K, V]) IterCb(fn IterCb[K, V]) {\n\tescape := false\n\tfor idx := range m.shards {\n\t\tshard := (m.shards)[idx]\n\t\tshard.RLock()\n\t\tfor key, value := range shard.items {\n\t\t\tif !fn(key, value) {\n\t\t\t\tescape = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tshard.RUnlock()\n\t\tif escape {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\n// Keys returns all keys as []string\nfunc (m ConcurrentMap[K, V]) Keys() []K {\n\tcount := m.Count()\n\tch := make(chan K, count)\n\tgo func() {\n\t\t// Foreach shard.\n\t\twg := sync.WaitGroup{}\n\t\twg.Add(SHARD_COUNT)\n\t\tfor _, shard := range m.shards {\n\t\t\tgo func(shard *ConcurrentMapShared[K, V]) {\n\t\t\t\t// Foreach key, value pair.\n\t\t\t\tshard.RLock()\n\t\t\t\tfor key := range shard.items {\n\t\t\t\t\tch <- key\n\t\t\t\t}\n\t\t\t\tshard.RUnlock()\n\t\t\t\twg.Done()\n\t\t\t}(shard)\n\t\t}\n\t\twg.Wait()\n\t\tclose(ch)\n\t}()\n\n\t// Generate keys\n\tkeys := make([]K, 0, count)\n\tfor k := range ch {\n\t\tkeys = append(keys, k)\n\t}\n\treturn keys\n}\n\n// Reviles ConcurrentMap \"private\" variables to json marshal.\nfunc (m ConcurrentMap[K, V]) MarshalJSON() ([]byte, error) {\n\t// Create a temporary map, which will hold all item spread across shards.\n\ttmp := make(map[K]V)\n\n\t// Insert items to temporary map.\n\tfor item := range m.IterBuffered() {\n\t\ttmp[item.Key] = item.Val\n\t}\n\treturn json.Marshal(tmp)\n}\nfunc strfnv32[K fmt.Stringer](key K) uint32 {\n\treturn fnv32(key.String())\n}\n\nfunc fnv32(key string) uint32 {\n\thash := uint32(2166136261)\n\tconst prime32 = uint32(16777619)\n\tkeyLength := len(key)\n\tfor i := 0; i < keyLength; i++ {\n\t\thash *= prime32\n\t\thash ^= uint32(key[i])\n\t}\n\treturn hash\n}\n\n// Reverse process of Marshal.\nfunc (m *ConcurrentMap[K, V]) UnmarshalJSON(b []byte) (err error) {\n\ttmp := make(map[K]V)\n\n\t// Unmarshal into a single map.\n\tif err := json.Unmarshal(b, &tmp); err != nil {\n\t\treturn err\n\t}\n\n\t// foreach key,value pair in temporary map insert into our concurrent map.\n\tfor key, val := range tmp {\n\t\tm.Set(key, val)\n\t}\n\treturn nil\n}\n"
	path := req.ConcurrentMap + "/concurrent_map.go"
	if err := gfile.PutContents(path, strings.TrimSpace(str)); err != nil {
		mlog.Fatalf("writing content to '%s' failed: %v", path, err)
	} else {
		utils.GoFmt(path)
		mlog.Print("generated:", path)
	}
}
